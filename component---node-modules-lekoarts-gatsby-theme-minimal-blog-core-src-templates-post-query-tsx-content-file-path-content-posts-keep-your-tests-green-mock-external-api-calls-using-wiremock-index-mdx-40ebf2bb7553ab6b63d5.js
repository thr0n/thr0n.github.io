"use strict";(self.webpackChunkthr0n_github_io=self.webpackChunkthr0n_github_io||[]).push([[686],{4765:function(e,t,n){n.d(t,{F:function(){return m},Z:function(){return d}});var r=n(7294),o=n(8733),i=n(795),a=n(6920),l=n(6799),s=n(8871);var c=e=>{let{post:t}=e;return null};const u=["16px","8px","4px"].map((e=>"rgba(0, 0, 0, 0.1) 0px "+e+" "+e+" 0px"));var p=e=>{let{data:{post:t},children:n}=e;return(0,o.tZ)(a.Z,null,(0,o.tZ)(i.X6,{as:"h1",variant:"styles.h1"},t.title),(0,o.tZ)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,o.tZ)("time",null,t.date),t.tags&&(0,o.tZ)(r.Fragment,null," ‚Äî ",(0,o.tZ)(l.Z,{tags:t.tags})),t.timeToRead&&" ‚Äî ",t.timeToRead&&(0,o.tZ)("span",null,t.timeToRead," min read")),(0,o.tZ)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:u.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},n),(0,o.tZ)(c,{post:t}))};const m=e=>{var t,n,r;let{data:{post:i}}=e;return(0,o.tZ)(s.Z,{title:i.title,description:i.description?i.description:i.excerpt,image:i.banner?null===(t=i.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(r=n.resize)||void 0===r?void 0:r.src:void 0,pathname:i.slug,canonicalUrl:i.canonicalUrl})};function d(e){let{...t}=e;return r.createElement(p,t)}},6799:function(e,t,n){var r=n(8733),o=n(7294),i=n(1883),a=n(3494),l=n(9706);t.Z=e=>{let{tags:t}=e;const{tagsPath:n,basePath:s}=(0,a.Z)();return(0,r.tZ)(o.Fragment,null,t.map(((e,t)=>(0,r.tZ)(o.Fragment,{key:e.slug},!!t&&", ",(0,r.tZ)(i.Link,{sx:e=>{var t;return{...null===(t=e.styles)||void 0===t?void 0:t.a}},to:(0,l.Z)("/"+s+"/"+n+"/"+e.slug)},e.name)))))}},2971:function(e,t,n){n.r(t),n.d(t,{Head:function(){return l.F},default:function(){return s}});var r=n(7294),o=n(1151);function i(e){const t=Object.assign({p:"p",ul:"ul",li:"li",blockquote:"blockquote",hr:"hr",h2:"h2",a:"a",pre:"pre",code:"code",h3:"h3"},(0,o.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.p,null,"When your software project is growing, chances are getting higher that you might want to (or have to üòâ) send API calls to an external system you do not control but have to communicate with in order to use a service they provide."),"\n",r.createElement(t.p,null,"Depending on your system's domain or your specific use case there are seemingly endless external services you could use. You may want to:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,'ensure that the visitor on your website isn\'t a bot (using "Google reCAPTCHA" or the like)'),"\n",r.createElement(t.li,null,"ask a geo information service for the latitude and longitude of a given address"),"\n",r.createElement(t.li,null,"add an item to a shopping cart service or many others"),"\n"),"\n",r.createElement(t.p,null,"Calling an external API during execution of your application is perfectly fine, because otherwise you won't be able to use their service at all. But since interacting with an external system always bears the risk of failures (downtimes, breaking changes, etc.) you will probably take actions to make your app resilient to failing API calls."),"\n",r.createElement(t.p,null,"Speaking of external systems and failures: If you added some tests to your project (and i hope you did!) you do not want to send real API calls to any external system during your tests. Calling real APIs during test execution is a bad practice. In general you don't want your tests to break if an external service is unavailable or behaving strange. Moreover,I assume that you don't want to test an external API, but rather focus on your application."),"\n",r.createElement(t.p,null,"But how can we test an application that uses external APIs without sending request to an external system? I'm glad you ask!"),"\n",r.createElement(t.p,null,"I used WireMock in several projects to achieve this goal. WireMock describes itself as:"),"\n",r.createElement(t.blockquote,null,"\n",r.createElement(t.p,null,"[‚Ä¶] a simulator for HTTP-based APIs. [‚Ä¶] It enables you to stay productive when an API you depend on doesn't exist or isn't complete. It supports testing of edge cases and failure modes that the real API won't reliably produce."),"\n"),"\n",r.createElement(t.p,null,"To me this sounds like a perfect match! If you now can't wait to use WireMock in your project you should definitely read on. I'll show you how to add WireMock to a Spring Boot/Kotlin application and how to test a Spring @Service that sends a GET request to an external API."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,null,"HandsOn: Use WireMock with Kotlin, Spring Boot, and JUnit¬†5"),"\n",r.createElement(t.p,null,"For this how-to i created a new project using Spring Initializr. It's up to you to decide if you start from scratch or add WireMock to your already existing project. In both cases you have to add Spring Web, Spring Configuration Processer and of course WireMock to your Gradle build file to get started."),"\n",r.createElement(t.p,null,"Afterwards we prepare the application.yml file to provide information about the external host. To keep this how-to as simple as possible we only add the hostname of the external service we want to communicate with. In this case it's just \"",r.createElement(t.a,{href:"http://example.org"},"http://example.org"),'":'),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-yaml"},'api:\n  product_availablity:\n    host: "http://example.org"\n')),"\n",r.createElement(t.p,null,"The hostname will be accessed using a @Configuration bean. This is necessary since later we will override this bean in our test configuration to set the hostname to a different value:"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-java"},'package com.medium.thr0n.wiremockdemo.configuration\n\nimport org.springframework.boot.context.properties.ConfigurationProperties\nimport org.springframework.context.annotation.Configuration\n\n@Configuration\n@ConfigurationProperties("api.productavailabilty")\nclass ProductAvailabilityProperties {\n    lateinit var host: String\n}\n')),"\n",r.createElement(t.p,null,"To call the external service we finally wire the Configuration bean into a simple demo service, read the current hostname and send the GET request using a RestTemplate:"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-java"},'package com.medium.thr0n.wiremockdemo.service\n\nimport com.medium.thr0n.wiremockdemo.configuration.ProductAvailabilityProperties\nimport org.springframework.http.HttpStatus\nimport org.springframework.stereotype.Service\nimport org.springframework.web.client.HttpClientErrorException\nimport org.springframework.web.client.RestTemplate\nimport org.springframework.web.server.ResponseStatusException\n\n@Service\nclass ProductAvailabilityService(val properties: ProductAvailabilityProperties) {\n    val restTemplate = RestTemplate()\n\n    fun isAvailable(articleId: String): String? {\n        try {\n            val response = restTemplate.getForEntity(\n                    properties.host + "/external-service/product-availability/" + articleId,\n                    String::class.java)\n            return response.body\n        } catch (e: HttpClientErrorException) {\n            throw ResponseStatusException(HttpStatus.NOT_FOUND)\n        }\n    }\n}\n')),"\n",r.createElement(t.p,null,"That was the implementation part. Simple, right? So, let's add a test!"),"\n",r.createElement(t.hr),"\n",r.createElement(t.p,null,"As said before we have to replace the configuration bean that stores the hostname of the external services, so we must allow bean definition overriding during test execution. To do so, we add a new application.yml file to src/test/resources/ and add the following configuration:"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-yaml"},"spring:\n  main:\n    allow-bean-definition-overriding: true\n")),"\n",r.createElement(t.p,null,"Now it's time to configure the WireMock server. First of all we tell WireMock to listen on a dynamic port. So hopefully we won't get into any trouble when our WireMock is executed by a CI/CD pipeline. To complete the WireMock setup we override the hostname of the external API to the baseUrl of the WireMock server. So from now on the ProductAvailabilityService will send all request to our WireMock instead of example.org."),"\n",r.createElement(t.p,null,"To receive valid responses from WireMock we add two simple stubs. The first stub will just respond with a HTTP status 200 if the given product id is equal to 1. If the product id is equal to 0 HTTP status 404 will be returned."),"\n",r.createElement(t.p,null,"Now we only have to start the WireMock server during the extension initialzitation. Ah, and don't forget to stop the WireMock inside the AfterAll function!"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-java"},'package com.medium.thr0n.wiremockdemo.junit\n\nimport com.github.tomakehurst.wiremock.WireMockServer\nimport com.github.tomakehurst.wiremock.client.WireMock.*\nimport com.github.tomakehurst.wiremock.core.WireMockConfiguration\nimport com.medium.thr0n.wiremockdemo.configuration.ProductAvailabilityProperties\nimport org.junit.jupiter.api.extension.AfterAllCallback\nimport org.junit.jupiter.api.extension.BeforeAllCallback\nimport org.junit.jupiter.api.extension.ExtensionContext\nimport org.springframework.boot.test.context.TestConfiguration\nimport org.springframework.context.annotation.Bean\nimport org.springframework.context.annotation.Primary\n\nprivate val productAvailabilityWiremockServer =\n    WireMockServer(WireMockConfiguration.options().dynamicPort())\n\n@TestConfiguration\nclass ProductAvailabilityWiremockExtension : BeforeAllCallback, AfterAllCallback {\n    val endpoint = "/external-service/product-availability"\n\n    init { productAvailabilityWiremockServer.start() }\n\n    @Bean\n    @Primary\n    fun productAvailabilityProperties(): ProductAvailabilityProperties {\n        val props = ProductAvailabilityProperties()\n        props.host = productAvailabilityWiremockServer.baseUrl()\n        return props\n    }\n\n    override fun beforeAll(context: ExtensionContext?) {\n        productAvailabilityWiremockServer.stubFor(\n                get(urlPathEqualTo("$endpoint/1"))\n                        .willReturn(ok())\n        )\n        productAvailabilityWiremockServer.stubFor(\n                get(urlPathEqualTo("$endpoint/0"))\n                        .willReturn(notFound())\n        )\n    }\n\n    override fun afterAll(context: ExtensionContext?) {\n        productAvailabilityWiremockServer.stop()\n    }\n}\n')),"\n",r.createElement(t.p,null,"If you think that this is just a very simple stub that doesn't that much, you're absolutely right! But for this how-to it's completely sufficient. Would you like to dive deeper into stubbing? Check out the WireMock docs, they have lots of examples: ",r.createElement(t.a,{href:"http://wiremock.org/docs/stubbing/"},"http://wiremock.org/docs/stubbing/")),"\n",r.createElement(t.p,null,"At the end it's time to add a @SpringBootTest. To use our WireMock we import the above extension class and extend the test with the same class. We use a TestRestTemplate to send GET request to a rest endpoint. The called endpoint will invoke the ProductAvailabilityService which in turn sends a GET request to the external API. But wait! Since the request is sent during test execution we won't ask example.org for the availability of a product. Instead WireMock will answer the request using the stub we defined above. Thank you, WireMock! üôè"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-java"},'package com.medium.thr0n.wiremockdemo.controllers\n\nimport com.medium.thr0n.wiremockdemo.junit.ProductAvailabilityWiremockExtension\nimport org.assertj.core.api.AssertionsForInterfaceTypes.assertThat\nimport org.junit.jupiter.api.Test\nimport org.junit.jupiter.api.extension.ExtendWith\nimport org.springframework.boot.test.context.SpringBootTest\nimport org.springframework.boot.test.web.client.TestRestTemplate\nimport org.springframework.boot.web.server.LocalServerPort\nimport org.springframework.context.annotation.Import\nimport org.springframework.http.HttpMethod\nimport org.springframework.http.HttpStatus\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@Import(ProductAvailabilityWiremockExtension::class)\n@ExtendWith(ProductAvailabilityWiremockExtension::class)\ninternal class ProductAvailabilityControllerIntTest(\n        @LocalServerPort val port: Int\n) {\n    val endpoint = "http://localhost:$port/api/product-availability"\n    val restTemplate = TestRestTemplate()\n\n    @Test\n    internal fun `Should return HTTP status OK for a valid product id`() {\n        val response = restTemplate.exchange(\n                "$endpoint/1",\n                HttpMethod.GET,\n                null,\n                String::class.java)\n        assertThat(response.statusCode).isEqualTo(HttpStatus.OK)\n    }\n\n    @Test\n    internal fun `Should return HTTP status NOT FOUND for an invalid product id`() {\n        val response = restTemplate.exchange(\n                "$endpoint/0",\n                HttpMethod.GET,\n                null,\n                String::class.java)\n        assertThat(response.statusCode).isEqualTo(HttpStatus.NOT_FOUND)\n    }\n}\n')),"\n",r.createElement(t.p,null,"It's a wrap! If you like to see or run this small WireMock example on your machine feel free to checkout the repo at Github: ",r.createElement(t.a,{href:"https://github.com/thr0n/medium-wiremock-demo"},"https://github.com/thr0n/medium-wiremock-demo")),"\n",r.createElement(t.p,null,"Do you have any questions regarding the how-to? Are you already using WireMock in your project? Or do you just want to say how great WireMock simplifies testing of applications that are interactiv with external APIs? I'm looking forward to reading your comment!"),"\n",r.createElement(t.p,null,"Happy mocking!"),"\n",r.createElement(t.h3,null,"Further reading"),"\n",r.createElement(t.p,null,"If you are interested in software reslience there are great articles out there. Here‚Äôs a short list just to name a few:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.a,{href:"https://blog.codecentric.de/en/2019/06/resilience-design-patterns-retry-fallback-timeout-circuit-breaker/"},"Resilience design patterns: retry, fallback, timeout, circuit breaker - codecentric AG Blog")),"\n",r.createElement(t.li,null,r.createElement(t.a,{href:"https://hackernoon.com/lets-talk-about-resilience-97051e14761f"},"Let's talk about Resilience")),"\n",r.createElement(t.li,null,r.createElement(t.a,{href:"https://dzone.com/articles/libraries-for-microservices-development"},"How to Make Services Resilient in a Microservices Environment - DZone Microservices")),"\n"))}var a=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,o.ah)(),e.components);return t?r.createElement(t,e,r.createElement(i,e)):i(e)},l=n(4765);function s(e){return r.createElement(l.Z,e,r.createElement(a,e))}l.Z}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-keep-your-tests-green-mock-external-api-calls-using-wiremock-index-mdx-40ebf2bb7553ab6b63d5.js.map